
use tokio::net::UdpSocket;
use tokio::sync::{mpsc, Mutex};
use std::sync::Arc;
use std::net::SocketAddr;
use bytes::Bytes;
use std::collections::{HashMap, VecDeque};
use std::time::Duration;
use crate::Result;
use super::packet::{PRUDPPacket, PRUDPHeader, Flags, Version};
use super::sliding::SlidingWindow;
use tracing::debug;
use parking_lot::Mutex as PLMutex;
use async_trait::async_trait;

// We'll forward payloads into an HPP handler channel.
pub type HppSender = mpsc::Sender<Bytes>;

// Represents a connection-level handler managing retransmit and sliding window.
pub struct Connection {
    pub peer: SocketAddr,
    socket: Arc<UdpSocket>,
    window: PLMutex<SlidingWindow>,
    // pending frames waiting for ack: seq -> (data, attempts)
    pending: Mutex<HashMap<u16, (Bytes, u8)>>,
    // queue of outgoing payloads waiting for admission
    send_queue: Mutex<VecDeque<Bytes>>,
    tx_notify: mpsc::Sender<()>,
    // hpp sender to forward delivered payloads
    hpp_tx: HppSender,
}

impl Connection {
    pub async fn new(socket: Arc<UdpSocket>, peer: SocketAddr, hpp_tx: HppSender) -> Self {
        let (tx, mut rx) = mpsc::channel::<()>(8);
        let rtt = std::sync::Arc::new(crate::rtt::RTT::new());
        let mut window = SlidingWindow::new(64);
        window.attach_rtt(rtt.clone());
        let conn = Connection {
            peer,
            socket,
            window: PLMutex::new(window),
            pending: Mutex::new(HashMap::new()),
            send_queue: Mutex::new(VecDeque::new()),
            tx_notify: tx.clone(),
            hpp_tx,
        };

        // Spawn retransmit task
        let socket_clone = conn.socket.clone();
        let peer_clone = conn.peer;
        let pending_clone = conn.pending.clone();
        let window_clone = conn.window.clone();
        tokio::spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_millis(200)).await;
                let expired: Vec<u16> = {
                    let w = window_clone.lock();
                    w.expired_packets()
                };
                if expired.is_empty() { continue; }
                let mut pending = pending_clone.lock().await;
                for seq in expired {
                    if let Some((data, attempts)) = pending.get_mut(&seq) {
                        if *attempts >= 5 {
                            tracing::warn!(seq = seq, "max retransmit attempts reached");
                            pending.remove(&seq);
                            continue;
                        }
                        // retransmit
                        debug!("retransmitting seq {}", seq);
                        let _ = socket_clone.send_to(&data[..], peer_clone).await;
                        *attempts += 1;
                        // update timestamp in sliding window
                        let mut w = window_clone.lock();
                        w.mark_sent(seq);
                    }
                }
            }
        });

        // Spawn sender task to drain send_queue respecting window
        let socket_tx = conn.socket.clone();
        let window_tx = conn.window.clone();
        let pending_tx = conn.pending.clone();
        let mut notify_rx = rx;
        let send_queue_ref = conn.send_queue.clone();
        tokio::spawn(async move {
            while let Some(_) = notify_rx.recv().await {
                loop {
                    let can = { window_tx.lock().can_send() };
                    if !can { break; }
                    // pop a payload
                    let mut q = send_queue_ref.lock().await;
                    let payload = match q.pop_front() {
                        Some(p) => p,
                        None => break,
                    };
                    drop(q);
                    // create packet with next sequence
                    let mut w = window_tx.lock();
                    let seq = w.next_sequence();
                    let header = PRUDPHeader {
                        version: Version::V0,
                        src: 0,
                        dst: 0,
                        flags: Flags::empty(),
                        session_id: 0,
                        seq,
                        payload_len: Some(payload.len() as u16),
                        signature: None,
                        multi_ack_mask: None,
                    };
                    let pkt = PRUDPPacket { header, payload: payload.clone() };
                    let bytes = pkt.to_bytes();
                    // send
                    if let Err(e) = socket_tx.send_to(&bytes[..], peer_clone).await {
                        tracing::error!("send error: {:?}", e);
                        // push back into queue
                        let mut q = send_queue_ref.lock().await;
                        q.push_front(payload);
                        break;
                    }
                    // record pending
                    let mut pend = pending_tx.lock().await;
                    pend.insert(seq, (bytes, 0u8));
                    drop(pend);
                    w.mark_sent(seq);
                }
            }
        });

        conn
    }

    pub async fn queue_send(&self, payload: Bytes) -> Result<()> {
        let mut q = self.send_queue.lock().await;
        q.push_back(payload);
        // notify sender
        let _ = self.tx_notify.send(()).await;
        Ok(())
    }

    pub async fn handle_incoming_packet(&self, pkt: PRUDPPacket) -> Result<()> {
        // If ACK flag present, mark acked/multi-acked
        if pkt.header.flags.contains(Flags::ACK) {
            // Update RTT estimator with a sample RTT - in a real implementation we'd measure per-packet timestamps
            if let Some(ref rtt) = None::<std::sync::Arc<crate::rtt::RTT>> {
                // placeholder
            }

            let seq = pkt.header.seq;
            // remove from pending
            let mut pend = self.pending.lock().await;
            if pend.remove(&seq).is_some() {
                let mut w = self.window.lock();
                w.mark_acked(seq);
            }
            if pkt.header.flags.contains(Flags::MULTI_ACK) {
                if let Some(mask) = pkt.header.multi_ack_mask {
                    let start = seq;
                    let mut w = self.window.lock();
                    w.mark_acked_range(start, mask);
                }
            }
            return Ok(());
        }
        // For data packets, attempt to deliver via sliding window
        let seq = pkt.header.seq;
        let payload_vec = pkt.payload.to_vec();
        let mut w = self.window.lock();
        let (ready, nak_opt) = w.offer_receive(seq, payload_vec);
        drop(w);
        // forward ready payloads to HPP handler
        for p in ready {
            let _ = self.hpp_tx.send(Bytes::from(p)).await;
        }
        // If NAK requested, send a NAK packet (we'll represent NAK as ACK+MULTI_ACK with mask)
        if let Some((start, mask)) = nak_opt {
            let ack_header = PRUDPHeader {
                version: pkt.header.version.clone(),
                src: pkt.header.dst,
                dst: pkt.header.src,
                flags: Flags::ACK | Flags::MULTI_ACK,
                session_id: pkt.header.session_id,
                seq: start,
                payload_len: Some(0),
                signature: None,
                multi_ack_mask: Some(mask),
            };
            let ack_pkt = PRUDPPacket { header: ack_header, payload: Bytes::from(vec![]) };
            let bytes = ack_pkt.to_bytes();
            let _ = self.socket.send_to(&bytes[..], self.peer).await;
        } else {
            // send normal ACK for the last-seen seq (seq)
            let ack_header = PRUDPHeader {
                version: pkt.header.version.clone(),
                src: pkt.header.dst,
                dst: pkt.header.src,
                flags: Flags::ACK,
                session_id: pkt.header.session_id,
                seq,
                payload_len: Some(0),
                signature: None,
                multi_ack_mask: None,
            };
            let ack_pkt = PRUDPPacket { header: ack_header, payload: Bytes::from(vec![]) };
            let bytes = ack_pkt.to_bytes();
            let _ = self.socket.send_to(&bytes[..], self.peer).await;
        }

        Ok(())
    }
}
